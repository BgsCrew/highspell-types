const fs = require('fs').promises;
const path = require('path');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const prettier = require('prettier');

/**
 * A map of minified names to our descriptive, developer-friendly names.
 */
const nameMappings = {
    'pW': 'GameLoop',
    'gW': 'GameEngine',
    'fW': 'InputManager',
    '_W': 'WildernessManager',
    'Lk': 'EntityManager',
    'Xk': 'SpellManager',
    'IF': 'WorldManager',
    'WR': 'AtmosphereManager',
    'FG': 'NetworkManager',
    'PV': 'SkillManager',
    'cR': 'TickManager',
    'dW': 'SpellActionManager',
    'yV': 'PacketFactory',
    'oq': 'UIManager',
    'aD': 'WorldEntityManger',
    'CN': 'GroundItemManager',
    'vF': 'MeshManager',
    'Dk': 'EntityFactory',
    'Ck': 'AppearanceManager',
    'qV': 'InventoryManager',
    'lG': 'QuestManager',
    'uG': 'ProjectileManager',
    'DG': 'ChatFilterManager',
    'jG': 'SocialManager',
    'AV': 'PlayerStatsManager',
    'SR': 'ObjectUrlManager',
    'zR': 'FogManager',
    'hF': 'CacheManager',
    'hk': 'BitmapManager',
};

/**
 * A map of PacketFactory method names to their manually-defined return types.
 * This is the core of the "prettifying" process.
 */
const packetMappings = {
    'createPublicMessageAction': 'Packets.PublicMessage',
    'createPlayerMoveToAction': 'Packets.PlayerMove',
    'createLoginAction': 'Packets.Login',
    'createEquippedItemAction': 'Packets.EquipItem',
    'createUnequippedItemAction': 'Packets.UnequipItem',
    'createShowDamageAction': 'Packets.ShowDamage',
    'createPlayerDiedAction': 'Packets.PlayerDied',
    'createPlayerEnteredChunkAction': 'Packets.PlayerEnteredChunk',
    'createNPCEnteredChunkAction': 'Packets.NPCEnteredChunk',
    'createItemEnteredChunkAction': 'Packets.ItemEnteredChunk',
    'createEntityExitedChunkAction': 'Packets.EntityExitedChunk',
    'createTeleportToAction': 'Packets.TeleportTo',
    'createPerformActionOnEntityAction': 'Packets.PerformActionOnEntity',
    'createUseItemOnEntityAction': 'Packets.UseItemOnEntity',
    'createSendMovementPathAction': 'Packets.SendMovementPath',
    'createCreateItemAction': 'Packets.CreateItem',
    'createUseItemOnItemAction': 'Packets.UseItemOnItem',
    'createInvokeInventoryItemActionAction': 'Packets.InvokeInventoryItemAction',
    'createReorganizeInventorySlotsAction': 'Packets.ReorganizeInventorySlots',
};


/**
 * Infers the TypeScript type from a Babel AST node.
 * @param {import('@babel/types').Node} node - The AST node.
 * @returns {string} The inferred TypeScript type.
 */
function inferType(node) {
    if (!node) return 'any';
    if (node.type === 'StringLiteral') return 'string';
    if (node.type === 'NumericLiteral') return 'number';
    if (node.type === 'BooleanLiteral') return 'boolean';
    if (node.type === 'NullLiteral') return 'null';
    if (node.type === 'NewExpression' && node.callee.name) return node.callee.name;
    if (node.type === 'ThisExpression') return 'this';
    return 'any';
}


/**
 * Generates the content for the game.d.ts file.
 * @param {object} singletons - The collected singleton data.
 * @returns {string} The content of the .d.ts file.
 */
function generateDtsContent(singletons) {
    // Base content now includes a reference to our manual packet definitions
    let dtsContent = `/// <reference types="@babylonjs/core" />\n/// <reference path="packets.d.ts" />\n\n/**\n * This file is auto-generated by the reverse-engineering script.\n * Do not edit it manually.\n */\n\ndeclare module "game" {\n    export import BABYLON = BABYLON;\n\n    // Forward declaration for the Managers namespace\n    namespace Managers {}\n    \n    // We need to declare the Packets namespace so the generated code can reference it.\n    export * from './packets';\n\n`;

    // Manually add class/interface definitions that are hard to infer
    dtsContent += `\n    export class Entity {\n        EntityID: number;\n        EntityType: any; // Could be an enum\n        Name: string;\n        Sprite: any; // Placeholder for Sprite class\n        MapLevel: number;\n        CurrentGamePosition: BABYLON.Vector3;\n        CombatLevel: number;\n        IsDestroyed: boolean;\n    }\n\n    export class Item {\n        _id: number;\n        _amount: number;\n    }\n\n    export interface CombatStats {\n        HitpointsExp: number;\n        HitpointsCurrLvl: number;\n        AccuracyExp: number;\n        AccuracyCurrLvl: number;\n        StrengthExp: number;\n        StrengthCurrLvl: number;\n        DefenseExp: number;\n        DefenseCurrLvl: number;\n        MagicExp: number;\n        MagicCurrLvl: number;\n        RangeExp: number;\n        RangeCurrLvl: number;\n        CombatStyle: any; // Enum\n        AutoRetaliate: boolean;\n        CombatLevel: number;\n    }\n\n    export interface SkillStats {\n        FishingExp: number;\n        FishingCurrLvl: number;\n        CookingExp: number;\n        CookingCurrLvl: number;\n        ForestryExp: number;\n        ForestryCurrLvl: number;\n        MiningExp: number;\n        MiningCurrLvl: number;\n        CraftingExp: number;\n        CraftingCurrLvl: number;\n        CrimeExp: number;\n        CrimeCurrLvl: number;\n        PotionmakingExp: number;\n        PotionmakingCurrLvl: number;\n        SmithingExp: number;\n        SmithingCurrLvl: number;\n        HarvestingExp: number;\n        HarvestingCurrLvl: number;\n        EnchantingExp: number;\n        EnchantingCurrLvl: number;\n    }\n\n    export interface Appearance {\n        HairStyleID: number;\n        BeardStyleID: number;\n        ShirtID: number;\n        BodyTypeID: number;\n        LegsID: number;\n    }\n\n    export class Player extends Entity {\n        PlayerType: any; // Enum\n        QuestCheckpoints: any;\n        PlayerSessionID: string;\n        ChatToken: string;\n        MentalClarity: number;\n        Combat: CombatStats;\n        Skills: SkillStats;\n        Inventory: Item[];\n        EquippedItems: Item[];\n        Appearance: Appearance;\n    }\n`;


    dtsContent += `    namespace Managers {\n`;

    for (const className in singletons) {
        const singleton = singletons[className];
        dtsContent += `\n        /**\n         * Originally: ${className}\n         */\n        export class ${singleton.descriptiveName} {\n            static readonly Instance: ${singleton.descriptiveName};\n${singleton.properties.map(prop => `            ${prop.name}: ${prop.type};`).join('\n')}\n${singleton.methods.map(method => `            ${method.name}(${method.params.join(', ')}): ${method.returnType};`).join('\n')}\n        }\n`;
    }

    dtsContent += `    }\n}\n`;

    return dtsContent;
}

/**
 * The main entry point for the type generation script.
 */
async function main() {
    console.log('Starting TypeScript definition generation...');

    try {
        const clientFilePath = path.resolve(__dirname, '../client.51.js');
        const clientCode = await fs.readFile(clientFilePath, 'utf-8');

        console.log('Parsing client code into AST...');
        const ast = parser.parse(clientCode, {
            sourceType: 'unambiguous',
            allowReturnOutsideFunction: true,
        });

        console.log('AST parsing complete. Traversing AST to find manager singletons...');

        const singletons = {};

        traverse(ast, {
            ClassDeclaration(path) {
                const className = path.node.id ? path.node.id.name : null;
                if (!className) return;

                let isSingleton = false;
                path.get('body').get('body').forEach(member => {
                    if (
                        member.isClassMethod({ kind: 'get', static: true }) &&
                        member.get('key').isIdentifier({ name: 'Instance' })
                    ) {
                        isSingleton = true;
                    }
                });

                if (isSingleton) {
                    const descriptiveName = nameMappings[className] || `UnknownManager_${className}`;
                    const methods = [];
                    const properties = [];

                    path.get('body').get('body').forEach(member => {
                        if (member.isClassMethod({ kind: 'method' })) {
                            const methodName = member.get('key').node.name;
                            if (!methodName.startsWith('_')) {
                                const params = member.get('params').map(paramPath => {
                                    if (paramPath.isIdentifier()) {
                                        return `${paramPath.node.name}: any`;
                                    } else if (paramPath.isAssignmentPattern()) {
                                        return `${paramPath.get('left').node.name}?: any`;
                                    }
                                    return 'param: any';
                                });

                                // --- The "Prettify" Logic ---
                                // Check if the method is in our manual packet mapping
                                let returnType = packetMappings[methodName];

                                // If not mapped, infer it
                                if (!returnType) {
                                    member.get('body').traverse({
                                        ReturnStatement(returnPath) {
                                            const arg = returnPath.get('argument');
                                            const inferred = inferType(arg.node);
                                            returnType = inferred === 'this' ? descriptiveName : inferred;
                                        }
                                    });
                                }
                                
                                // Default to void if still no type
                                if (!returnType) {
                                    returnType = 'void';
                                }

                                methods.push({ name: methodName, params: params, returnType: returnType });
                            }
                        }
                    });
                    
                    const constructor = path.get('body').get('body').find(member => member.isClassMethod({ kind: 'constructor' }));
                    if (constructor) {
                        constructor.get('body').get('body').forEach(statement => {
                            if (statement.isExpressionStatement() && statement.get('expression').isAssignmentExpression()) {
                                const assignment = statement.get('expression');
                                const left = assignment.get('left');
                                if (left.isMemberExpression() && left.get('object').isThisExpression()) {
                                    const propName = left.get('property').node.name;
                                    if (!propName.startsWith('_')) {
                                        const propType = inferType(assignment.get('right').node);
                                        properties.push({ name: propName, type: propType });
                                    }
                                }
                            }
                        });
                    }


                    singletons[className] = {
                        descriptiveName: descriptiveName,
                        methods: methods,
                        properties: [...new Map(properties.map(item => [item.name, item])).values()], // Deduplicate properties
                    };
                }
            }
        });

        console.log('Singleton analysis complete.');

        console.log('Generating and formatting d.ts content...');
        const rawDtsContent = generateDtsContent(singletons);
        const formattedDtsContent = await prettier.format(rawDtsContent, { parser: "typescript" });

        const distDir = path.resolve(__dirname, '../dist');
        await fs.mkdir(distDir, { recursive: true });

        const generatedDtsPath = path.resolve(distDir, 'generated.d.ts');
        await fs.writeFile(generatedDtsPath, formattedDtsContent);
        console.log(`Successfully generated generated.d.ts at ${generatedDtsPath}`);

        console.log('Copying manual type definitions to dist...');
        const srcDir = path.resolve(__dirname, '../src');
        const manualFiles = await fs.readdir(srcDir);
        for (const file of manualFiles) {
            const srcPath = path.resolve(srcDir, file);
            const destPath = path.resolve(distDir, file);
            const content = await fs.readFile(srcPath, 'utf-8');
            const formattedContent = await prettier.format(content, { parser: "typescript" });
            await fs.writeFile(destPath, formattedContent);
            console.log(`Copied and formatted ${file} to ${destPath}`);
        }

        console.log('Build process complete.');

    } catch (error) {
        console.error('An error occurred during type generation:', error);
    }
}

main();
